<!doctype html>
<html lang="en">
    <head>
        <title>Sailboat Tracker</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        />
        <script
            type="text/javascript"
            src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        ></script>
        <script
            type="text/javascript"
            src="https://rawgit.com/bbecquet/Leaflet.RotatedMarker/master/leaflet.rotatedMarker.js"
        ></script>
        <style>
            #map {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
            }
        </style>
    </head>

    <body>
        <div id="map"></div>
        <script type="text/javascript">
            class map_interface {
                static map_options = {
                    center: [0, 0],
                    zoom: 13,
                    enableHighAccuracy: true
                };

                static icon_cache = new Map();

                static assets_url = "http://localhost:8000/";
                static buoy_color = "orange";
                static waypoint_color = "blue";
                static focused_waypoint_color = "violet";

                /**
                 * Returns a cached icon of the specified color.
                 * @param {string} color
                 * @return {L.Icon}
                 */
                static get_icon(color) {
                    const key = `marker-${color}`;
                    if (!this.icon_cache.has(key)) {
                        this.icon_cache.set(
                            key,
                            L.icon({
                                iconUrl:
                                    this.assets_url +
                                    `marker-icon-${color}.png`,
                                shadowUrl:
                                    this.assets_url + "marker-shadow.png",
                                iconSize: [25, 41],
                                iconAnchor: [12, 41],
                                shadowSize: [41, 41]
                            })
                        );
                    }
                    return this.icon_cache.get(key);
                }

                /**
                 * Returns a boat icon scaled by the specified factor.
                 * @param {number} scale
                 * @return {L.Icon}
                 */
                static get_boat_icon(scale = 1) {
                    return L.icon({
                        iconUrl: this.assets_url + "boat.png",
                        iconSize: [50 * scale, 50 * scale],
                        iconAnchor: [25 * scale, 25 * scale]
                    });
                }

                constructor() {
                    this.lastFocusedTimeStamp = performance.now();
                    this.waypoints = [];
                    this.buoys = [];
                    this.boat = { heading: 0, location: [0, 0] };

                    this.min_zoom = 5;
                    this.max_zoom = 20;
                    this.currentZoom = map_interface.map_options.zoom;

                    this.waypointMarkers = new Map();
                    this.buoyMarkers = new Map();
                    this.focusedWaypoint = null;
                    this.lastFocusedColor = map_interface.waypoint_color;

                    this.map = L.map("map", map_interface.map_options);
                    this.currentZoom = this.map.getZoom();

                    L.tileLayer(
                        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                        { minZoom: this.min_zoom, maxZoom: this.max_zoom }
                    ).addTo(this.map);

                    L.control.scale().addTo(this.map);

                    let moveTimeout;
                    this.map.on("move", () => {
                        clearTimeout(moveTimeout);
                        moveTimeout = setTimeout(
                            () => this.handle_map_move(),
                            100
                        );
                    });

                    this.map.on("click", e => {
                        this.add_waypoint(e.latlng.lat, e.latlng.lng);
                    });

                    this.map.on("contextmenu", e => {
                        this.handle_right_click(e);
                    });

                    this.boat_marker = L.marker(this.boat.location, {
                        icon: map_interface.get_boat_icon(),
                        rotationAngle: this.boat.heading,
                        rotationOrigin: "center"
                    }).addTo(this.map);

                    // this.map.on("zoomend", () => {
                    //     const newZoom = this.map.getZoom();
                    //     if (newZoom !== this.currentZoom) {
                    //         this.currentZoom = newZoom;
                    //         this.zoom_icons(newZoom);
                    //     }
                    // });
                }

                /**
                 * Handles map movement to unfocus waypoints after a delay.
                 */
                handle_map_move() {
                    if (!this.focusedWaypoint) return;
                    const diff = performance.now() - this.lastFocusedTimeStamp;
                    if (diff > 1000) {
                        this.unfocus_waypoint();
                    }
                }

                /**
                 * Handles right-click events to remove the closest waypoint.
                 * @param {Object} e - The event object containing latlng.
                 */
                handle_right_click(e) {
                    let closest_index = -1;
                    let closest_distance = Infinity;
                    this.waypoints.forEach((waypoint, index) => {
                        const distance = Math.sqrt(
                            (waypoint[0] - e.latlng.lat) ** 2 +
                                (waypoint[1] - e.latlng.lng) ** 2
                        );
                        if (distance < closest_distance && distance < 0.05) {
                            closest_index = index;
                            closest_distance = distance;
                        }
                    });
                    if (closest_index !== -1) {
                        this.remove_waypoint(closest_index);
                    }
                }

                /**
                 * Unfocuses the currently focused waypoint.
                 */
                unfocus_waypoint() {
                    if (this.focusedWaypoint) {
                        const marker = this.waypointMarkers.get(
                            this.focusedWaypoint
                        );
                        if (marker) {
                            marker.setIcon(
                                map_interface.get_icon(this.lastFocusedColor)
                            );
                        }
                        this.focusedWaypoint = null;
                    }
                }

                /**
                 * Adjusts icon sizes based on zoom level.
                 * @param {number} zoom
                 */
                zoom_icons(zoom) {
                    const scale = Math.pow(
                        2,
                        zoom - map_interface.map_options.zoom
                    );
                    this.boat_marker.setIcon(
                        map_interface.get_boat_icon(scale)
                    );

                    const updateMarker = (marker, isBoat = false) => {
                        const iconUrl = marker.options.icon.options.iconUrl;
                        if (iconUrl.includes("marker-icon") || isBoat) {
                            const newIcon = L.icon({
                                iconUrl: iconUrl,
                                shadowUrl:
                                    map_interface.assets_url +
                                    "marker-shadow.png",
                                iconSize: [25 * scale, 41 * scale],
                                iconAnchor: [12 * scale, 41 * scale],
                                shadowSize: [41 * scale, 41 * scale]
                            });
                            marker.setIcon(newIcon);
                        }
                    };

                    this.waypointMarkers.forEach(marker =>
                        updateMarker(marker)
                    );
                    this.buoyMarkers.forEach(marker => updateMarker(marker));
                }

                /**
                 * Synchronizes waypoints with the server.
                 * @return {Promise<void>}
                 */
                async sync_waypoints() {
                    try {
                        const response = await fetch(
                            "http://localhost:3001/waypoints",
                            {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({
                                    waypoints: this.waypoints
                                })
                            }
                        );
                        if (!response.ok) {
                            console.error("Failed to sync waypoints");
                        }
                    } catch (error) {
                        console.error("Error syncing waypoint:", error);
                    }
                }

                // Waypoint Methods

                /**
                 * Adds a waypoint to the map and syncs it with the server.
                 * @param {number} lat
                 * @param {number} lon
                 */
                add_waypoint(lat, lon) {
                    const key = `${lat},${lon}`;
                    if (this.waypointMarkers.has(key)) {
                        console.log("Waypoint already exists.");
                        return;
                    }

                    this.waypoints.push([lat, lon]);
                    const marker = L.marker([lat, lon], {
                        icon: map_interface.get_icon(
                            map_interface.waypoint_color
                        )
                    }).addTo(this.map);
                    this.waypointMarkers.set(key, marker);
                    this.sync_waypoints();
                }

                /**
                 * Removes the waypoint at the specified index.
                 * @param {number} index
                 */
                remove_waypoint(index) {
                    const [lat, lon] = this.waypoints.splice(index, 1)[0];
                    const key = `${lat},${lon}`;
                    const marker = this.waypointMarkers.get(key);
                    if (marker) {
                        this.map.removeLayer(marker);
                        this.waypointMarkers.delete(key);
                    }
                    if (this.focusedWaypoint === key) {
                        this.focusedWaypoint = null;
                    }
                    this.sync_waypoints();
                }

                /**
                 * Changes the color of all waypoints on the map.
                 * @param {string} color
                 */
                change_color_waypoints(color) {
                    this.waypointMarkers.forEach(marker => {
                        marker.setIcon(map_interface.get_icon(color));
                    });
                }

                /**
                 * Clears all waypoints from the map.
                 */
                clear_waypoints() {
                    this.waypointMarkers.forEach(marker => {
                        this.map.removeLayer(marker);
                    });
                    this.waypointMarkers.clear();
                    this.waypoints = [];
                    this.focusedWaypoint = null;
                    this.sync_waypoints();
                }

                // Buoy Methods

                /**
                 * Adds a buoy to the map.
                 * @param {number} lat
                 * @param {number} lon
                 */
                add_buoy(lat, lon) {
                    const key = `${lat},${lon}`;
                    this.buoys.push([lat, lon]);
                    const marker = L.marker([lat, lon], {
                        icon: map_interface.get_icon(map_interface.buoy_color)
                    }).addTo(this.map);
                    this.buoyMarkers.set(key, marker);
                }

                /**
                 * Removes the buoy at the specified index.
                 * @param {number} index
                 */
                remove_buoy(index) {
                    const [lat, lon] = this.buoys.splice(index, 1)[0];
                    const key = `${lat},${lon}`;
                    const marker = this.buoyMarkers.get(key);
                    if (marker) {
                        this.map.removeLayer(marker);
                        this.buoyMarkers.delete(key);
                    }
                }

                /**
                 * Clears all buoys from the map.
                 */
                clear_buoys() {
                    this.buoyMarkers.forEach(marker => {
                        this.map.removeLayer(marker);
                    });
                    this.buoyMarkers.clear();
                    this.buoys = [];
                }

                // Boat Telemetry Methods

                /**
                 * Updates the boat's location on the map.
                 * @param {number} lat
                 * @param {number} lon
                 */
                update_boat_location(lat, lon) {
                    this.boat.location = [lat, lon];
                    this.boat_marker.setLatLng(this.boat.location);
                }

                /**
                 * Updates the boat's heading on the map.
                 * @param {number} heading
                 */
                update_boat_heading(heading) {
                    this.boat.heading = heading;
                    this.boat_marker.setRotationAngle(90 - heading);
                }

                /**
                 * Updates both location and heading.
                 * @param {number} lat
                 * @param {number} lon
                 * @param {number} heading
                 */
                update_boat_location_and_heading(lat, lon, heading) {
                    this.update_boat_location(lat, lon);
                    this.update_boat_heading(heading);
                }

                // Map Focus Methods

                /**
                 * Focuses the map on the boat.
                 */
                focus_map_on_boat() {
                    this.map.setView(this.boat.location, this.map.getZoom());
                }

                /**
                 * Focuses the map on a specific marker.
                 * @param {number} lat
                 * @param {number} lon
                 */
                focus_map_on_marker(lat, lon) {
                    const key = `${lat},${lon}`;
                    const marker =
                        this.waypointMarkers.get(key) ||
                        this.buoyMarkers.get(key);

                    if (!marker) return;

                    this.lastFocusedTimeStamp = performance.now();
                    this.map.setView([lat, lon], this.map.getZoom());

                    if (this.focusedWaypoint && this.focusedWaypoint !== key) {
                        const prevMarker = this.waypointMarkers.get(
                            this.focusedWaypoint
                        );
                        if (prevMarker) {
                            prevMarker.setIcon(
                                map_interface.get_icon(this.lastFocusedColor)
                            );
                        }
                    }

                    if (this.waypointMarkers.has(key)) {
                        this.lastFocusedColor = map_interface.waypoint_color;
                        this.focusedWaypoint = key;
                        marker.setIcon(
                            map_interface.get_icon(
                                map_interface.focused_waypoint_color
                            )
                        );
                    }
                }
            }

            const map = new map_interface();
        </script>
    </body>
</html>
